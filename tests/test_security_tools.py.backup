#!/usr/bin/env python3
"""
ğŸ§ª å®‰å…¨å·¥å…·æµ‹è¯•å¥—ä»¶
==================

æµ‹è¯•å®‰å…¨æ¼æ´ä¿®å¤å·¥å…·çš„å„é¡¹åŠŸèƒ½
"""

import unittest
import tempfile
import shutil
import os
from pathlib import Path
from typing import Any
import sys

# æ·»åŠ é¡¹ç›®æ ¹ç›®å½•åˆ°è·¯å¾„
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

try:
    from fix_vulnerabilities import SecurityFixer
except ImportError as e:
    print(f"æ— æ³•å¯¼å…¥ SecurityFixer: {e}")
    print("è¯·ç¡®ä¿åœ¨é¡¹ç›®æ ¹ç›®å½•è¿è¡Œæ­¤æµ‹è¯•")
    sys.exit(1)


class TestSecurityFixer(unittest.TestCase):
    """å®‰å…¨ä¿®å¤å™¨æµ‹è¯•ç±»"""
    
    def setUp(self):
        """æµ‹è¯•å‰å‡†å¤‡"""
        # åˆ›å»ºä¸´æ—¶ç›®å½•ç”¨äºæµ‹è¯•
        self.test_dir = tempfile.mkdtemp()
        self.test_project = Path(self.test_dir)
        
        # åˆ›å»ºæ¨¡æ‹Ÿçš„ requirements.txt
        self.requirements_file = self.test_project / "requirements.txt"
        with open(self.requirements_file, "w") as f:
            f.write("""# Test requirements
requests>=2.25.0
numpy>=1.20.0
# some comment
pandas==1.3.0  # with comment
flask
""")
        
        # åˆ›å»º SecurityFixer å®ä¾‹
        self.fixer = SecurityFixer(str(self.test_project))
    
    def tearDown(self):
        """æµ‹è¯•åæ¸…ç†"""
        shutil.rmtree(self.test_dir)
    
    def test_init(self):
        """æµ‹è¯•åˆå§‹åŒ–"""
        self.assertEqual(self.fixer.project_root, self.test_project)
        self.assertEqual(len(self.fixer.backup_file_paths), 0)
    
    def test_backup_files(self):
        """æµ‹è¯•æ–‡ä»¶å¤‡ä»½åŠŸèƒ½"""
        # æ‰§è¡Œå¤‡ä»½
        self.fixer.backup_files()
        
        # æ£€æŸ¥å¤‡ä»½æ–‡ä»¶æ˜¯å¦åˆ›å»º
        backup_file = self.test_project / "requirements.txt.backup"
        self.assertTrue(backup_file.exists())
        
        # æ£€æŸ¥å¤‡ä»½å†…å®¹æ˜¯å¦æ­£ç¡®
        with open(backup_file, "r") as f:
            backup_content = f.read()
        
        with open(self.requirements_file, "r") as f:
            original_content = f.read()
        
        self.assertEqual(backup_content, original_content)
        
        # æ£€æŸ¥å¤‡ä»½æ–‡ä»¶è·¯å¾„è®°å½•
        self.assertEqual(len(self.fixer.backup_file_paths), 1)
        self.assertEqual(self.fixer.backup_file_paths[0], backup_file)
    
    def test_check_tools_basic(self):
        """æµ‹è¯•å·¥å…·æ£€æŸ¥åŠŸèƒ½ï¼ˆåŸºç¡€æµ‹è¯•ï¼‰"""
        # è¿™ä¸ªæµ‹è¯•ä¸ä¾èµ–å®é™…å®‰è£…çš„å·¥å…·
        result = self.fixer.check_tools()
        # ç”±äºåœ¨æµ‹è¯•ç¯å¢ƒä¸­å·¥å…·å¯èƒ½æœªå®‰è£…ï¼Œæˆ‘ä»¬åªæ£€æŸ¥è¿”å›ç±»å‹
        self.assertIsInstance(result, bool)
    
    def test_scan_results_parsing(self):
        """æµ‹è¯•æ‰«æç»“æœè§£æ"""
        # æ¨¡æ‹Ÿ pip-audit ç»“æœ
        mock_pip_audit = {
            "dependencies": [
                {
                    "name": "requests",
                    "version": "2.25.0",
                    "vulnerabilities": []
                }
            ]
        }
        
        # æ¨¡æ‹Ÿ safety ç»“æœ
        mock_safety = {
            "vulnerabilities": []
        }
        
        # æµ‹è¯•ä¿®å¤åŠŸèƒ½ä¸ä¼šå´©æºƒ
        fix_results = self.fixer.fix_vulnerabilities(mock_safety, mock_pip_audit)
        
        # æ£€æŸ¥è¿”å›ç»“æœæ ¼å¼
        self.assertIsInstance(fix_results, dict)
        self.assertIn("fixed", fix_results)
        self.assertIn("failed", fix_results)
        self.assertIsInstance(fix_results["fixed"], list)
        self.assertIsInstance(fix_results["failed"], list)
    
    def test_generate_report(self):
        """æµ‹è¯•æŠ¥å‘Šç”ŸæˆåŠŸèƒ½"""
        # å‡†å¤‡æµ‹è¯•æ•°æ®
        safety_results = {"vulnerabilities": []}
        pip_audit_results = {"dependencies": []}
        fix_results = {"fixed": ["test-package"], "failed": []}
        
        # ç”ŸæˆæŠ¥å‘Š
        self.fixer.generate_report(safety_results, pip_audit_results, fix_results)
        
        # æ£€æŸ¥æŠ¥å‘Šæ–‡ä»¶æ˜¯å¦åˆ›å»º
        report_file = self.test_project / "security_report.md"
        self.assertTrue(report_file.exists())
        
        # æ£€æŸ¥æŠ¥å‘Šå†…å®¹
        with open(report_file, "r", encoding="utf-8") as f:
            content = f.read()
        
        self.assertIn("å®‰å…¨æ¼æ´ä¿®å¤æŠ¥å‘Š", content)
        self.assertIn("æ‰«æå·¥å…·", content)
        self.assertIn("ä¿®å¤ç»“æœ", content)
        self.assertIn("test-package", content)


class TestProjectStructure(unittest.TestCase):
    """é¡¹ç›®ç»“æ„æµ‹è¯•"""
    
    def setUp(self):
        self.project_root = Path(__file__).parent.parent
    
    def test_required_files_exist(self):
        """æµ‹è¯•å¿…éœ€æ–‡ä»¶æ˜¯å¦å­˜åœ¨"""
        required_files = [
            "fix_vulnerabilities.py",
            "scripts/fix_vulnerabilities.sh",
            "requirements.txt",
            ".github/workflows/security-check.yml",
            ".github/dependabot.yml",
        ]
        
        for file_path in required_files:
            file_full_path = self.project_root / file_path
            self.assertTrue(
                file_full_path.exists(),
                f"å¿…éœ€æ–‡ä»¶ {file_path} ä¸å­˜åœ¨"
            )
    
    def test_scripts_executable(self):
        """æµ‹è¯•è„šæœ¬æ–‡ä»¶æ˜¯å¦å¯æ‰§è¡Œ"""
        scripts = [
            "fix_vulnerabilities.py",
            "scripts/fix_vulnerabilities.sh",
        ]
        
        for script in scripts:
            script_path = self.project_root / script
            if script_path.exists():
                # æ£€æŸ¥æ˜¯å¦æœ‰æ‰§è¡Œæƒé™ï¼ˆUnixç³»ç»Ÿï¼‰
                if os.name != 'nt':  # éWindowsç³»ç»Ÿ
                    self.assertTrue(
                        os.access(script_path, os.X_OK),
                        f"è„šæœ¬ {script} æ²¡æœ‰æ‰§è¡Œæƒé™"
                    )
    
    def test_workflow_syntax(self):
        """æµ‹è¯•GitHubå·¥ä½œæµæ–‡ä»¶è¯­æ³•"""
        workflow_file = self.project_root / ".github/workflows/security-check.yml"
        
        if workflow_file.exists():
            # åŸºæœ¬è¯­æ³•æ£€æŸ¥ï¼šç¡®ä¿æ–‡ä»¶æ˜¯æœ‰æ•ˆçš„YAML
            import yaml
            try:
                with open(workflow_file, 'r', encoding='utf-8') as f:
                    workflow_content = yaml.safe_load(f)
                
                # æ£€æŸ¥å¿…è¦çš„å·¥ä½œæµé”®
                self.assertIn("name", workflow_content)
                self.assertIn("on", workflow_content)
                self.assertIn("jobs", workflow_content)
                
            except yaml.YAMLError as e:
                self.fail(f"å·¥ä½œæµæ–‡ä»¶YAMLè¯­æ³•é”™è¯¯: {e}")
    
    def test_dependabot_syntax(self):
        """æµ‹è¯•Dependaboté…ç½®æ–‡ä»¶è¯­æ³•"""
        dependabot_file = self.project_root / ".github/dependabot.yml"
        
        if dependabot_file.exists():
            import yaml
            try:
                with open(dependabot_file, 'r', encoding='utf-8') as f:
                    dependabot_content = yaml.safe_load(f)
                
                # æ£€æŸ¥å¿…è¦çš„Dependaboté”®
                self.assertIn("version", dependabot_content)
                self.assertIn("updates", dependabot_content)
                self.assertEqual(dependabot_content["version"], 2)
                
            except yaml.YAMLError as e:
                self.fail(f"Dependaboté…ç½®æ–‡ä»¶YAMLè¯­æ³•é”™è¯¯: {e}")


if __name__ == "__main__":
    # è®¾ç½®æµ‹è¯•è¿è¡Œå™¨
    unittest.main(verbosity=2)